{
  "name": "Python excel",
  "tagline": "",
  "body": "### Welcome to GitHub Pages.\r\n  1、导入模块\r\n\r\n      import xlrd\r\n\r\n   2、打开Excel文件读取数据\r\n\r\n       data = xlrd.open_workbook('excelFile.xls')\r\n\r\n   3、使用技巧\r\n\r\n        获取一个工作表\r\n\r\n \r\n\r\n        table = data.sheets()[0]          #通过索引顺序获取\r\n \r\n        table = data.sheet_by_index(0) #通过索引顺序获取\r\n \r\n\r\n        table = data.sheet_by_name(u'Sheet1')#通过名称获取\r\n \r\n        获取整行和整列的值（数组）\r\n 　　\r\n         table.row_values(i)\r\n \r\n         table.col_values(i)\r\n \r\n        获取行数和列数\r\n　　\r\n        nrows = table.nrows\r\n \r\n        ncols = table.ncols\r\n       \r\n        循环行列表数据\r\n        for i in range(nrows ):\r\n      print table.row_values(i)\r\n \r\n单元格\r\ncell_A1 = table.cell(0,0).value\r\n \r\ncell_C4 = table.cell(2,3).value\r\n \r\n使用行列索引\r\ncell_A1 = table.row(0)[0].value\r\n \r\ncell_A2 = table.col(1)[0].value\r\n \r\n简单的写入\r\nrow = 0\r\n \r\ncol = 0\r\n \r\n# 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error\r\nctype = 1 value = '单元格的值'\r\n \r\nxf = 0 # 扩展的格式化\r\n \r\ntable.put_cell(row, col, ctype, value, xf)\r\n \r\ntable.cell(0,0)  #单元格的值'\r\n \r\ntable.cell(0,0).value #单元格的值'\r\n \r\n### Designer Templates\r\n# -*- coding: utf-8 -*- \r\nimport  xdrlib ,sys\r\nimport xlrd\r\ndef open_excel(file= 'file.xls'):\r\n    try:\r\n        data = xlrd.open_workbook(file)\r\n        return data\r\n    except Exception,e:\r\n        print str(e)\r\n#根据索引获取Excel表格中的数据   参数:file：Excel文件路径     colnameindex：表头列名所在行的所以  ，by_index：表的索引\r\ndef excel_table_byindex(file= 'file.xls',colnameindex=0,by_index=0):\r\n    data = open_excel(file)\r\n    table = data.sheets()[by_index]\r\n    nrows = table.nrows #行数\r\n    ncols = table.ncols #列数\r\n    colnames =  table.row_values(colnameindex) #某一行数据 \r\n    list =[]\r\n    for rownum in range(1,nrows):\r\n\r\n         row = table.row_values(rownum)\r\n         if row:\r\n             app = {}\r\n             for i in range(len(colnames)):\r\n                app[colnames[i]] = row[i] \r\n             list.append(app)\r\n    return list\r\n\r\n#根据名称获取Excel表格中的数据   参数:file：Excel文件路径     colnameindex：表头列名所在行的所以  ，by_name：Sheet1名称\r\ndef excel_table_byname(file= 'file.xls',colnameindex=0,by_name=u'Sheet1'):\r\n    data = open_excel(file)\r\n    table = data.sheet_by_name(by_name)\r\n    nrows = table.nrows #行数 \r\n    colnames =  table.row_values(colnameindex) #某一行数据 \r\n    list =[]\r\n    for rownum in range(1,nrows):\r\n         row = table.row_values(rownum)\r\n         if row:\r\n             app = {}\r\n             for i in range(len(colnames)):\r\n                app[colnames[i]] = row[i]\r\n             list.append(app)\r\n    return list\r\n\r\ndef main():\r\n   tables = excel_table_byindex()\r\n   for row in tables:\r\n       print row\r\n\r\n   tables = excel_table_byname()\r\n   for row in tables:\r\n       print row\r\n\r\nif __name__==\"__main__\":\r\n    main()\r\n\r\n### Creating pages manually\r\n　　今天一同学给我发来一个Excel文件,让我帮他找一些信息,打开一开 8000多条数据。自己手工处理是不可能完成的的啦。作为一名程序员,当然要用程序来处理。处理生活中的问题当然是Python最为方便啦。利用万能的 Google 搜索 Python Excel,点击第一条结果http://www.python-excel.org/ ，发先这个东西 能够跨平台处理 Excel。废话不多说,按照文档一步步去做,要安装 三个包 xlrd(用于读Excel), xlwt(用于写Excel),xlutils(处理Excel的工具箱)。\r\n\r\n　　上面的英文文档很齐全，这里就不多说了,因为我只需要获取Excel里面的数据,所以只要简单的读取出来。\r\nfrom xlrd import open_workbook\r\nimport re\r\n\r\n#创建一个用于读取sheet的生成器,依次生成每行数据,row_count 用于指定读取多少行, col_count 指定用于读取多少列\r\ndef readsheet(s, row_count=-1, col_cout=-1):#\r\n    # Sheet 有多少行\r\n    nrows = s.nrows\r\n    # Sheet 有多少列\r\n    ncols = s.ncols\r\n    row_count = (row_count if row_count > 0 else nrows)\r\n    col_count = (col_count if col_count > 0 else ncols)\r\n    row_index = 0\r\n    while row_index < row_count:\r\n        yield [s.cell(row_index, col).value for col in xrange(col_count)]\r\n        row_index += 1\r\n\r\nwb = open_workbook('simple.xls') #打开Excel文件\r\n# 读取Excel中所有的Sheet\r\nfor s in wb.sheets():\r\n    for row in readsheet(s, 10, 10):# 只读取每个Sheet的前10行，前10列(当然你要确保,你的数据多余10行，且多余10列)\r\n        print row\r\n\r\n　　非常简单, 主要用到 xlrd 四个特性 open_workbook , wb.sheets(), s.nrows-(行数),s.ncols -(列数),  s.cell(row, col).value- (获取指定单位处的值)。\r\n\r\n　　这几个函数用于处理一般的读取操作完全够了。\r\n\r\n### Authors and Contributors\r\n\r\nhttp://www.cnblogs.com/zhoujie/p/python18.html\r\n　　最近遇到一个情景，就是定期生成并发送服务器使用情况报表，按照不同维度统计，涉及python对excel的操作，上网搜罗了一番，大多大同小异，而且不太能满足需求，不过经过一番对源码的\"研究\"（用此一词让我觉得颇有成就感）之后，基本解决了日常所需。主要记录使用过程的常见问题及解决。\r\n\r\n　　python操作excel主要用到xlrd和xlwt这两个库，即xlrd是读excel，xlwt是写excel的库。可从这里下载https://pypi.python.org/pypi。下面分别记录python读和写excel.\r\n\r\n \r\n\r\npython读excel——xlrd\r\n\r\n这个过程有几个比较麻烦的问题，比如读取日期、读合并单元格内容。下面先看看基本的操作：\r\n\r\n首先读一个excel文件，有两个sheet，测试用第二个sheet，sheet2内容如下：\r\n\r\n\r\n\r\npython 对 excel基本的操作如下：\r\n# -*- coding: utf-8 -*-\r\nimport xlrd\r\nimport xlwt\r\nfrom datetime import date,datetime\r\n\r\ndef read_excel():\r\n    # 打开文件\r\n    workbook = xlrd.open_workbook(r'F:\\demo.xlsx')\r\n    # 获取所有sheet\r\n    print workbook.sheet_names() # [u'sheet1', u'sheet2']\r\n    sheet2_name = workbook.sheet_names()[1]\r\n\r\n    # 根据sheet索引或者名称获取sheet内容\r\n    sheet2 = workbook.sheet_by_index(1) # sheet索引从0开始\r\n    sheet2 = workbook.sheet_by_name('sheet2')\r\n\r\n    # sheet的名称，行数，列数\r\n    print sheet2.name,sheet2.nrows,sheet2.ncols\r\n\r\n    # 获取整行和整列的值（数组）\r\n    rows = sheet2.row_values(3) # 获取第四行内容\r\n    cols = sheet2.col_values(2) # 获取第三列内容\r\n    print rows\r\n    print cols\r\n\r\n    # 获取单元格内容\r\n    print sheet2.cell(1,0).value.encode('utf-8')\r\n    print sheet2.cell_value(1,0).encode('utf-8')\r\n    print sheet2.row(1)[0].value.encode('utf-8')\r\n    \r\n    # 获取单元格内容的数据类型\r\n    print sheet2.cell(1,0).ctype\r\n\r\nif __name__ == '__main__':\r\n    read_excel()\r\n\r\n### Support or Contact\r\n\r\nhttp://my.oschina.net/dddttttt/blog/466103\r\n\r\n\r\nPython xlrd、xlwt、xlutils读取、修改Excel文件\r\n\r\n\r\n\r\n\r\n一、xlrd读取excel\r\n\r\n \r\n\r\n这里介绍一个不错的包xlrs,可以工作在任何平台。这也就意味着你可以在Linux下读取Excel文件。\r\n\r\n首先，打开workbook；    \r\nimport xlrd\r\nwb = xlrd.open_workbook('myworkbook.xls')\r\n\r\n检查表单名字：    \r\nwb.sheet_names()\r\n\r\n得到第一张表单，两种方式：索引和名字    \r\nsh = wb.sheet_by_index(0)\r\nsh = wb.sheet_by_name(u'Sheet1')\r\n\r\n递归打印出每行的信息：    \r\nfor rownum in range(sh.nrows):\r\n    print sh.row_values(rownum)\r\n\r\n如果只想返回第一列数据：\r\nfirst_column = sh.col_values(0)\r\n\r\n通过索引读取数据：    \r\ncell_A1 =  sh.cell(0,0).value\r\ncell_C4 = sh.cell(rowx=3,colx=2).value\r\n\r\n注意：这里的索引都是从0开始的。\r\n\r\n \r\n\r\n一、安装xlrd模块\r\n\r\n   到python官网下载http://pypi.python.org/pypi/xlrd模块安装，前提是已经安装了python 环境。\r\n\r\n二、使用介绍\r\n\r\n  1、导入模块\r\n\r\n      import xlrd\r\n\r\n   2、打开Excel文件读取数据\r\n\r\n       data = xlrd.open_workbook('excelFile.xls')\r\n\r\n   3、使用技巧\r\n\r\n        获取一个工作表\r\n\r\n         table = data.sheets()[0]          #通过索引顺序获取\r\n\r\n        table = data.sheet_by_index(0) #通过索引顺序获取\r\n\r\n        table = data.sheet_by_name(u'Sheet1')#通过名称获取\r\n\r\n        获取整行和整列的值（数组）\r\n\r\n         table.row_values(i)\r\n\r\n         table.col_values(i)\r\n\r\n        获取行数和列数\r\n\r\n　　   nrows = table.nrows\r\n\r\n       ncols = table.ncols\r\n\r\n       循环行列表数据\r\n\r\n        for i in range(nrows ):\r\n\r\n      print table.row_values(i);\r\n\r\n单元格\r\n\r\ncell_A1 = table.cell(0,0).value\r\n\r\n \r\n\r\ncell_C4 = table.cell(2,3).value\r\n\r\n \r\n\r\n使用行列索引\r\n\r\ncell_A1 = table.row(0)[0].value\r\n\r\ncell_A2 = table.col(1)[0].value\r\n\r\n简单的写入\r\n\r\nrow = 0\r\n\r\ncol = 0\r\n\r\n \r\n\r\n# 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error\r\n\r\nctype = 1 value = '单元格的值'\r\n\r\nxf = 0 # 扩展的格式化 \r\n\r\ntable.put_cell(row, col, ctype, value, xf)\r\n\r\ntable.cell(0,0)  #单元格的值'\r\n\r\ntable.cell(0,0).value #单元格的值'\r\n\r\n二、xlwt写excel \r\n\r\n这里介绍一个不错的包xlwt,可以工作在任何平台。这也就意味着你可以在Linux下保存Excel文件。\r\n\r\n \r\n\r\n基本部分\r\n\r\n在写入Excel表格之前，你必须初始化workbook对象，然后添加一个workbook对象。比如：\r\nimport xlwt\r\nwbk = xlwt.Workbook()\r\nsheet = wbk.add_sheet('sheet 1')\r\n\r\n这样表单就被创建了,写入数据也很简单：\r\n# indexing is zero based, row then column\r\nsheet.write(0,1,'test text')\r\n\r\n之后，就可以保存文件(这里不需要想打开文件一样需要close文件)：\r\nwbk.save('test.xls')\r\n\r\n深入探索\r\n\r\nworksheet对象，当你更改表单内容的时候，会有警告提示。\r\nsheet.write(0,0,'test')\r\nsheet.write(0,0,'oops')\r\n \r\n# returns error:\r\n# Exception: Attempt to overwrite cell:\r\n# sheetname=u'sheet 1' rowx=0 colx=0\r\n\r\n解决方式：使用cell_overwrite_ok=True来创建worksheet:\r\nsheet2 =  wbk.add_sheet('sheet 2', cell_overwrite_ok=True)\r\nsheet2.write(0,0,'some text')\r\nsheet2.write(0,0,'this should overwrite')\r\n\r\n这样你就可以更改表单2的内容了。\r\n\r\n更多\r\n# Initialize a style\r\nstyle = xlwt.XFStyle()\r\n \r\n# Create a font to use with the style\r\nfont = xlwt.Font()\r\nfont.name = 'Times New Roman'\r\nfont.bold = True\r\n \r\n# Set the style's font to this new one you set up\r\nstyle.font = font\r\n \r\n# Use the style when writing\r\nsheet.write(0, 0, 'some bold Times text', style)\r\n\r\nxlwt 允许你每个格子或者整行地设置格式。还可以允许你添加链接以及公式。其实你可以阅读源代码，那里有很多例子：\r\n\r\n    dates.py, 展示如何设置不同的数据格式\r\n    hyperlinks.py, 展示如何创建超链接 (hint: you need to use a formula)\r\n    merged.py, 展示如何合并格子\r\n    row_styles.py, 展示如何应用Style到整行格子中.\r\n\r\n \r\n\r\n三 xlutils修改excel \r\n\r\n \r\n\r\nPython中一般使用xlrd（excel read）来读取Excel文件，使用xlwt（excel write）来生成Excel文件（可以控制Excel中单元格的格式），需要注意的是，用xlrd读 取excel是不能对其进行操作的：xlrd.open_workbook()方法返回xlrd.Book类型，是只读的，不能对其进行操作。而 xlwt.Workbook()返回的xlwt.Workbook类型的save(filepath)方法可以保存excel文件。因此对于读取和生成Excel文件都非常容易处理，但是对于已经存在的Excel文件进行修改就比较麻烦了。不过，还有一个xlutils（依赖于xlrd和xlwt）提供复制excel文件内容和修改文件的功能。其实际也只是在xlrd.Book和xlwt.Workbook之间建立了一个管道而已，如下图：\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\nxlutils.copy模块的copy()方法实现了这个功能，示例代码如下：\r\n\r\nfrom xlrd import open_workbook\r\nfrom xlutils.copy import copy\r\n \r\nrb = open_workbook('m:\\\\1.xls')\r\n \r\n#通过sheet_by_index()获取的sheet没有write()方法\r\nrs = rb.sheet_by_index(0)\r\n \r\nwb = copy(rb)\r\n \r\n#通过get_sheet()获取的sheet有write()方法\r\nws = wb.get_sheet(0)\r\nws.write(0, 0, 'changed!')\r\n \r\nwb.save('m:\\\\1.xls')\r\n\r\n \r\n\r\n四 参考 \r\n\r\nhttp://pypi.python.org/pypi/xlrd\r\n\r\nhttp://pypi.python.org/pypi/xlwt\r\n\r\nhttp://pypi.python.org/pypi/xlutils\r\n\r\n \r\n\r\n本文整合自 \r\n\r\nhttp://www.leyond.info/write-excel-files-with-python-using-xlwt/\r\n\r\nhttp://www.leyond.info/read-excel-from-python-using-xlrs/\r\n\r\nhttp://www.zhlwish.com/2010/10/09/python_edit_excel/\r\n\r\n### Support or Contact\r\n\r\nPython读取和写入Excel文件[整] (2013-02-25 12:11:35)转载▼\r\n标签： 杂谈\t分类： python\r\n详见百度空间：http://hi.baidu.com/ilovelittree/item/62270cdf54fff132d80e4468\r\n\r\n学习用Python处理Excel文件，这里主要用xlrd和xlwt模块，用前需要安装！本文是来自几篇博客和官网tutorial的整理，主要是一个入门。更多的处理Excel的方法请到官网学习，链接为：http://www.simplistix.co.uk/presentations/python-excel.pdf\r\n另外，几篇博客的参考资料：\r\nhttp://syue.com/Software/Language/Python/21655.html\r\nhttp://blog.csdn.net/wangxiaoyan1988/article/details/6562374\r\nhttp://www.2cto.com/kf/201207/140006.html\r\n \r\n \r\nA：Excel数据的类型及组织方式\r\n\r\n\r\n每一个Excel数据文件从上至下分为三个层级的对象：\r\nworkbook： 每一个Excel文件就是一个workbook。\r\nsheet： 每一个workbook中可以包含多个sheet，具体就对应Excel中我们在左下脚所看到的“sheet1”,“sheet2”等。\r\ncell： 每一个sheet就是我们通常所看到的一个表格，可以含有m行，n列，每个确定的行号，列号所对应的一个格子就是一个cell。\r\n \r\n \r\nB: 从Excel中读取数据\r\n\r\n从一个既有的xlsx文件中读取数据，按照Excel文件的三个层级，分别做以下三个步骤\r\n \r\n1. 打开workbook：\r\nimport xlrd\r\nbook = xlrd.open_workbook(\"myfile.xls\")    #book就赋值为一个Excel文件了\r\n \r\n注：\r\nBook 类的方法、属性等：即就可以对上面的book进行操作了\r\nbook.nsheets:  在Book对象中的文件有多少个worksheet\r\nbook.sheet_by_index(sheetx): 根据提供的sheetx索引来获取我们需要的sheet表，返回的是一个Sheet类的实例。\r\nbook.sheet_by_name(sheet_name): 根据提供的sheet_name来获取对应名称的sheet类对象，返回的也是一个Sheet类的对象\r\nbook.sheet_names(): 在Book对象中的所有sheet表的名称列表\r\nbook.sheets(): 返回在Book对象中所有的Sheet对象实例列表\r\n \r\n2. 打开所需的sheet：\r\nsh = book.sheet_by_index(0)  #获得一个sheet,也可以使名字获得\r\nprint sh.name, sh.nrows, sh.ncols\r\n注：\r\nSheet类方法、属性等：\r\nsh.cell(rowx, colx): 根据给出的行和列的参数获取得到cell类，返回一个Cell类实例对象\r\nsh.cell_type(rowx, colx): 返回对应的cell对象的Type类型\r\nsh.cell_value(rowx, colx): 返回对应的cell对象的value值\r\nsh.col(colx): 返回指定列的所有cell类对象序列\r\nsh.name: 返回sheet对象的名称\r\nsh.ncols: 返回在sheet对象中的列的数目\r\nsh.nrows: 返回在sheet对象中的行的数目\r\nsh.row(rowx): 返回指定的行的所有cell对象的序列\r\n \r\n \r\n3. 获取对应cell的值：\r\ncell=sh.cell(rowx=29, colx=3) #根据给出的行和列的参数获取得到cell类，返回一个Cell类实例对象\r\nsh.cell_value(rowx=29, colx=3)\r\n \r\nCell类的属性、方法如下：\r\nCell类对象有3种属性：ctype, value, xf_index\r\n如果在excel文件打开的时候，formatting_info未启用的时候，xf_index是为None\r\n下面列出了cell的类型，以及他们在python中所代表的值\r\ntype symbol          type number                python value\r\nXL_CELL_EMPTY             0                      空的字符串''\r\nXL_CELL_TEXT              1                      unicode字符串\r\nXL_CELL_NUMBER            2                      float\r\nXL_CELL_DATE              3                      float\r\nXL_CELL_BOOLEAN           4                      int;1 --- True,0 --- False\r\nXL_CELL_ERROR             5                      int代表是一个excel内部错误码；\r\nXL_CELL_BLANK             6                      空的字符串'', 注意：这个类型仅仅会出现，当函数open_workbook(..,formatting_info=True)这样设置的时候\r\n \r\n4.一个读取Excel的例子\r\n \r\nimport xlrd\r\nbook = xlrd.open_workbook(\"myfile.xls\")\r\nprint \"The number of worksheets is\", book.nsheets\r\nprint \"Worksheet name(s):\", book.sheet_names()\r\nsh = book.sheet_by_index(0)\r\nprint sh.name, sh.nrows, sh.ncols\r\nprint \"Cell D30 is\", sh.cell_value(rowx=29, colx=3)\r\nfor rx in range(sh.nrows):\r\n    print sh.row(rx)\r\n \r\n \r\nC: Writing Excel Files\r\n \r\nAll the examples shown below can be found in the xlwt directory of the course material.读Excel xlrd模块，写用xlwt模块\r\n \r\n1.     Creating elements within a Workbook创建一个Excel文件\r\n \r\nImport xlwt\r\nwb=xlwt.Workbook(“zc.xls”) #Workbook 首字母大写\r\n \r\n \r\n2.    Worksheets 添加Sheet\r\n \r\nWorksheets are created with the add_sheet method of the Workbook class.\r\nTo retrieve an existing sheet from a Workbook, use its get_sheet method. This method is particularly useful when the Workbook has been instantiated by xlutils.copy.\r\n \r\nSheet1=wb.add_sheet(“sheetname”)\r\n \r\n \r\n3.    Rows and Columns 行与列的表示：\r\n \r\nrow1 = sheet1.row(1)\r\ncol0=sheet2.col(0)\r\n \r\n4.    Cells\r\n \r\nCells can be written using either the write method of either the Worksheet or Row class.\r\nsheet1.write(0,1,'B1')\r\nrow1.write(0,'A2')\r\n \r\n5.    svave  保存文件：\r\n \r\nwb.save(“zc.xls”)\r\n \r\n6.    Excel写入的一个简单的例子\r\nfrom xlwt import Workbook\r\nbook = Workbook()\r\nsheet1 = book.add_sheet('Sheet 1')  #添加一个sheet\r\nbook.add_sheet('Sheet 2')\r\nsheet1.write(0,0,'A1')   #通过sheet添加cell值\r\nsheet1.write(0,1,'B1')\r\nrow1 = sheet1.row(1)\r\nrow1.write(0,'A2')     #还可以通过row属性添加cell值\r\nrow1.write(1,'B2')\r\nsheet1.col(0).width = 10000\r\nsheet2 = book.get_sheet(1)\r\nsheet2.row(0).write(0,'Sheet 2 A1')  #又一种添加\r\nsheet2.row(0).write(1,'Sheet 2 B1')\r\nsheet2.flush_row_data()\r\nsheet2.write(1,0,'Sheet 2 A3')\r\nsheet2.col(0).width = 5000\r\nsheet2.col(0).hidden = True\r\nbook.save('simple.xls')\r\n \r\nD： 稍微复杂的例子和巩固\r\nEx1:\r\n \r\nimport xlrd\r\nfname = \"sample.xls\"   #一个文件路径和文件名\r\nbk = xlrd.open_workbook(fname)    #打开一个workbook\r\nshxrange = range(bk.nsheets)   #各个sheet之间的转换？\r\ntry:     #提取sheet1？\r\n    sh = bk.sheet_by_name(\"Sheet1\")\r\nexcept:\r\n    print \"no sheet in %s named Sheet1\" % fname\r\n    return None\r\nnrows = sh.nrows\r\nncols = sh.ncols\r\nprint \"nrows %d, ncols %d\" % (nrows, ncols)\r\n\r\ncell_value = sh.cell_value(1,1)\r\nprint cell_value\r\n\r\nrow_list = []\r\nfor i in range(1, nrows):\r\n    row_data = sh.row_values(i)\r\n    row_list.append(row_data)\r\n \r\n \r\nex2:\r\n 1\r\n2 import xlrd\r\n 3 import xlwt\r\n 4\r\n 5 class OperExcel():\r\n 6   #读取Excel表\r\n 7   def rExcel(self,inEfile,outfile):\r\n 8     rfile = xlrd.open_workbook(inEfile)\r\n 9     #创建索引顺序获取一个工作表\r\n10     table = rfile.sheet_by_index(0)\r\n11     #其他方式\r\n12     #table = rfile.sheets()[0]\r\n13     #table = rfile.sheet_by_name(u'Sheet1')\r\n14\r\n15     #获取整行，整列的值\r\n16     table.row_values(0)\r\n17     table.col_values(0)\r\n18\r\n19     #获取行数和列数\r\n20     nrows = table.nrows - 1\r\n21     ncols = table.ncols\r\n22\r\n23     #循环获取列表的数据\r\n24     #for i in range(nrows):\r\n25     #  print table.row_values(i)\r\n26     wfile = open(outfile,'w')\r\n27     #获取第一列中的所有值\r\n28     for i in range(nrows):\r\n29       #table.cell(i,0).value获取某一单元格的值\r\n30       wfile.write(table.cell(i,0).value.encode('utf8') + '\\n')\r\n31     wfile.close()\r\n32\r\n33 #将数据写入Excel表\r\n34   def wExcel(self,infile,outEfile):\r\n35     rfile = open(infile,'r')\r\n36     buf = rfile.read().split('\\n')\r\n37     rfile.close()\r\n38\r\n39     w = xlwt.Workbook()\r\n40     sheet = w.add_sheet('sheet1')\r\n41     for i in range(len(buf)):\r\n42       print buf[i]\r\n43       sheet.write(i,0,buf[i].decode('utf8'))\r\n44     w.save(outEfile)\r\n45\r\n46 if __name__ == '__main__':\r\n47   t = OperExcel()\r\n48   t.rExcel('test.xls','test')\r\n49   t.wExcel('test','1.xls')\r\n50 #  作者：sunrise\r\n\r\n\r\n\r\n\r\n### Support or Contact\r\n\r\n    因为经常会涉及到从Excel表中导数据，所以就学习了python的xlrd来读取excel中的数据。\r\n1.xlrd的安装\r\n        xlrd是python的第三方库，所以是需要自己安装的，可以在python的官网http://pypi.python.org/pypi/xlrd下载该模块来安装，也可以通过其他手段，比如easy_install或者pip啥的，我已经安装好pip所以就用最懒的方式来安装了pip install xlrd来安装。\r\n2.分析excel文件的层级对象\r\n        要读取excel的数据，就要了解excel的结构，根据excel的结构一层一层的去读取数据。\r\n        excel有三层级对象，workbook，sheet，和cell。一个excel文件就是一个workbook，所以在最初我们必须要打开这个excel文件，也就是workbook。sheet我们都很熟悉，就是表，我们都知道一个excel文件有时候会有很多的表，所以我们必须要选择是读取哪个表的数据，最后才是cell，cell其实就是格子，excel的表格就是一个二维数组，cell就是这个表格中的最小单元，也就是我们读取数据存储的地方。\r\n3.xlrd读取excel的基本操作\r\n        python是一个很强大的脚本语言，之所以强大是因为它的库很强大，xlrd作为python的第三方库已经将读取excel文件的各个操作封装好了，我们只需要调用它提供的一些接口就可以很快速简单的读取数据。下面看看最基本的操作。\r\n1).打开一个excel文件得到数据：\r\ndata = xlrd.open_workbook(\"test.xls\")\r\n\r\n2).获取一个表格数据\r\ntable = data.sheets()[0]            #通过索引获取\r\ntable = data.sheet_by_index(0)      #通过索引获取\r\ntable = data.sheet_by_name('set')   #通过表名获取\r\n\r\n3).获取表格数据\r\nnrows = table.nrows                 #行数\r\nncols = table.ncols                 #列数\r\ndata = table.cell(nrow, ncol).value #得到表格数据\r\n#获取每行每列的数据\r\nfor i in range(0, nrows):\r\n    for j in range(0, ncols):\r\n        data = table.cell(i, j).value\r\n\r\n\r\n### Support or Contact\r\n数据处理:Python使用xlrd包读取Excel表格数据NOV,24 2013\r\n在日常的数据处理工作中，我们经常会有批量处理Excel文件的需求。比如历史上定期的Excel报价表格，或者是会员信息等等。针对多个文件的数据处理，VBA宏是一种方案，而用Python进行处理也是一种好的办法。\r\n\r\n这两天看见人力忙着核对绩效，手动工作量十分大，于是我主动提出帮她们减轻负担啦！她们的需求是每月有一批绩效考核文件，需要打开每个核对与汇总绩效成绩是否一致。  \r\n说明：Python的Excel包有很多，我使用的是xlrd包，地址： https://pypi.python.org/pypi/xlrd/0.9.2 。 \r\n首先我们要明白excel文件的组织结构：\r\n\r\ncell:单元格。就是excel表中一个个的小格子，我们在里面输入数据，也可以通过行与列来表示这个小格子的位置； \r\nsheet:工作表。我们通常新建一个新的excel，会在excel界面的底部看到有个3个新的工作表-”sheet1,sheet2,sheet3“。一个工作表是由N多个cell单元格组成，他是excel文件的中层结构。 \r\nExcel文件:office官方文档称呼为”工作簿“，它由多个sheet组成，是excel的最高层。\r\n理解了上面excel组织结构后，我们就能很好的理解excel的相关函数了。 \r\n从最简单的一段代码说起：\r\n\r\n\r\n   1:  import xlrd #引入包\r\n   2:  book = xlrd.open_workbook(\"myfile.xls\") \r\n   3:  #创建一个book class，打开excel文件\r\n   4:  print \"The number of worksheets is\", book.nsheets \r\n   5:  # nsheets属性记录一个excel文件中有多少个sheet\r\n   6:  print \"Worksheet name(s):\", book.sheet_names() \r\n   7:  #返回sheet name的list\r\n   8:  sh = book.sheet_by_index(0)   \r\n   9:  #获取一个sheet对象\r\n  10:  print sh.name, sh.nrows, sh.ncols   \r\n  11:  # sheet的属性：name,rows,cols\r\n  12:  print \"Cell D30 is\", sh.cell_value(rowx=29, colx=3) \r\n  13:  #定位一个cell\r\n  14:  for rx in range(sh.nrows):\r\n  15:      print sh.row(rx)  #按照row输出excel数据\r\n  16:   \r\n\r\n上面这段代码打开了一个叫”myfile.xls“的文件，使用的方法是xlrd.open_workbook()。我们知道一个excel文件中可以有多个sheet，所以我们可以用book.nsheets属性知道这个文件有多少个sheet.\r\n\r\n接下来是获取sheet的操作：使用book.sheet_by_index(0)获取第一个sheet对象。我们获取sheet对象，可以使用index定位，也可以使用name定位，比如sheet_by_name（xxx）。\r\n\r\n获取完sheet对象后，就可以读取具体的单元格数据啦。按行读取，按列读取等可以按需选择。\r\n\r\n附：之前需求的处理代码，其实很简单：\r\n\r\n   1:  def get_kpi(file):\r\n   2:      book = xlrd.open_workbook(file)    \r\n   3:      #print \"The number of worksheets is\", book.nsheets\r\n   4:      for shnum in range(0,book.nsheets):\r\n   5:          rowx=0\r\n   6:          sh = book.sheet_by_index(shnum)\r\n   7:          if re.search('he',sh.name)!=None:\r\n   8:              pass\r\n   9:          else:\r\n  10:              rowx=sh.col_values(0).index(u'总评得分：')\r\n  11:              for rVaule in sh.row_slice(rowx,1,3):\r\n  12:                  if rVaule.ctype==2:\r\n  13:                      print sh.name,rVaule.value\r\n\r\n### fsfsdfsdf\r\nhttps://gerald.top/note/python-excel\r\nPython读写Excel文件\r\n\r\n Sep 29, 2014\r\n背景\r\n\r\n其实我本来是不愿意面对Python读写Excel文件这个问题的，因为Excel文件的标准并不公开，而且发展至今有了很多版本，所以即使通过第三方库实现了读写，也依然不能保证没有兼容性问题，因此以前遇到这个问题的时候，我都是选择逃避，使用CSV/TSV之类的读写来替代，绝无后顾之忧。\r\n\r\n但是，这一次因为最终需要生成包含多个表单的Excel文件，因此还是直接操作比较省事，至于为什么用Python，因为……文字处理哪家强？（脑补一下。。）\r\n\r\n牵涉到的问题：\r\n\r\nPython版本支持？\r\n\r\nPython出了不能向后兼容的3.x之后，很多旧版的库都支持不了，而3.x对Unicode的支持让我无法放弃，于是我会比较喜欢能支持3.x的库。\r\n\r\nExcel版本支持？\r\n\r\nExcel历史悠久，版本众多，但是还好主要可以分为2类，XLS(97-2003)和XLSX(2007+)。\r\n\r\nXLS的局限性：最大行数为65535，最大列数为255。\r\n\r\n发现\r\n\r\n通过几个小时的学习，终于得到了以下几种通过Python第三方库操作Excel文件的方法：\r\n\r\n来自Python-Excel的第三方库（xlrd、xlwt、xlutils）\r\n\r\n这种方法其实是由三个库组成：\r\n\r\nxlrd (Excel Reader): 读\r\n\r\n支持Python 2.x和3.x，支持XLS和XLSX文件读取。\r\n\r\nxlwt (Excel Writer): 写\r\n\r\n仅支持Python 2.x，仅支持写XLS。\r\n\r\n但是后来又找到了这个版本的一个支持Python 3.x的fork：xlwt-future，不过还是只支持写XLS。\r\n\r\nxlutils: 更多高级操作，依赖前2个库\r\n\r\n仅支持Python 2.x。\r\n\r\nopenpyxl\r\n\r\n支持Python 2.x和3.x，仅支持XLSX的读取和写入。\r\n\r\n使用\r\n\r\n由于xlutils不支持Python 3.x，所以我就直接放弃了，通过xlrd和xlwt来读写和通过openpyxl来读写，用法其实挺相似的，对照文档写并不困难。\r\n\r\n这时候就要考虑到效率了，比如同样是打开一个1.5MB的XLSX文件（openpyxl不支持XLS，所以对于XLS就没有选择了，而我只需要能处理XLSX就足够了），如果我需要取每个表的指定行，耗时上有多大差异？粗略地在网上看了一下，似乎大家都推荐了xlrd来读取，而且有人说xlrd的读取速度比openpyxl快很多，但是我的实践中恰好相反。\r\n\r\n先上代码，分别使用xlrd和openpyxl从 data.xlsx 读取第一行的内容：\r\n\r\n使用xlrd\r\n\r\n\r\nimport xlrd\r\nwb=xlrd.open_workbook(filename='data.xlsx', on_demand=True)\r\nfor i in range(wb.nsheets):\r\n        ws=wb.sheet_by_index(i)\r\n        for j in ws.row(0):\r\n                print(j.value)\r\n        wb.unload_sheet(i)\r\n使用openpyxl\r\n\r\nimport openpyxl\r\nwb=openpyxl.load_workbook(filename='data.xlsx', use_iterators=True)\r\nsheetnames=wb.get_sheet_names()\r\nfor i in sheetnames:\r\n        ws=wb.get_sheet_by_name(i)\r\n        it=ws.iter_rows()\r\n        for j in next(it):\r\n                print(j.value)\r\n由于鄙人比较懒，所以就只比较了一下总时间，打开一个1.5MB有6张表的XLSX文件，第1种方法用时8秒，第2种方法用时1秒，两种方法都是按需加载表格，通过直觉（部分代码未提供）可以发现两种方法的耗时都主要花在打开表格这一步上，也就是说，打开表格后从每个表中读取第一行其实花的时间并不多。而在打开XLSX文件上，xlrd就比openpyxl明显慢了很多。\r\n\r\n于是我果断选择了openpyxl，输出的时候遇到一个小插曲：\r\n\r\nimport openpyxl\r\nwb=openpyxl.Workbook(optimized_write=True)\r\nws=wb.create_sheet()\r\n\r\nfor irow in range(100):\r\n    ws.append(['%d' % i for i in range(20)])\r\nwb.save(filename='data.xlsx')\r\n\r\n\r\n这是直接从官方文档里抄来了一个简单例子，顺利地生成了一个 data.xlsx 文件，然后用WPS打开的时候就提示出错了！检查了半天觉得程序应该没错了，于是就怀疑是openpyxl坏掉了？最后抱着试一试的态度，用LibreOffice打开了一下，很正常哇！我用WPS已经很久没遇到过打不开的文件了，所以推测：使用openpyxl生成的XLSX文件虽然符合标准，但可能还是有一些细节和MS Office生成的XLSX文件不同，而WPS的容错能力不够所以就直接报错了，不如去上报一下~\r\n\r\n2014-10-31 更新：\r\n\r\nWPS个人版更新到9.1.0.4867，再打开这个文件就正常了！\r\n\r\n\r\n###用Python读取Excel(*.xls)文件——xlrd模块的使用\r\n简介\r\n\r\nxlrd是python的一个第三方模块，可以实现跨平台读Microsoft Excel文件。（它有一个兄弟叫xlwt，专注于写Excel文件。）\r\n它并不像win2com那样借助COM技术来访问Excel，而是直接分析Excel文件格式，从中解析数据。因此你可以在任何支持python的平台上使用excel文件。这一点它比win2com要优秀得多。\r\n另外，它对unicode支持的很好，这也是我青睐它的重要原因。\r\n它的工作原理所限，我们不能期望它覆盖Excel全部的功能，访问到全部的数据。\r\n比如，下面这些数据类型xlrd会忽略掉：\r\n\r\n图表，宏，图片等嵌入对象（包括嵌入的worksheet）。\r\nVBA模块。\r\n公式（只能识别公式的计算结果，而不是公式本身）。\r\n注释。\r\n链接。\r\n但一些简单的读取还是得心应手的，这已经能满足大多数情况下的需求。\r\n现在它能支持的Excel版本包括：2004, 2003, XP, 2000, 97, 95, 5.0, 4.0, 3.0, 2.1, 2.0。 官方未说明它是否能支持Excel 2007。\r\n它有两个分支，分别是：\r\n\r\nxlrd （http://pypi.python.org/pypi/xlrd） 针对Python 2.x系列。\r\nxlrd3（http://pypi.python.org/pypi/xlrd3） 针对Python 3.x系列。\r\n\r\n这两个分支是100%兼容的，也就是说，它们的使用完全一样，你在3.x系列中怎么用xlrd，在2.x系列中仍然这么用。\r\n以下的实际操作都使用xlrd3，在python 3.2下完成。\r\n\r\n安装\r\n\r\nxlrd在python官网的发布主页是http://pypi.python.org/pypi/xlrd3 ，当前xlrd3的最新版本是0.1.4。\r\n下载得到一个压缩包，假设我们将它解压到D:\\Download\\xlrd3-0.1.4，可以看到如下文件。\r\n可以看到有文档、示例、测试文件等。注意其中的setup.py，它是标准的python模块安装方式。\r\n先确认一下python的版本与xlrd3是否一致。\r\n\r\nD:\\Download\\xlrd3-0.1.4>python -V\r\nPython 3.2.2\r\n\r\nOK，我们用的是python3，接下来执行安装脚本。\r\n\r\nD:\\Download\\xlrd3-0.1.4>python setup.py install\r\n\r\n一长串输出后，没有看到错误的话，xlrd就安装成功了。\r\n\r\n试用\r\n\r\n假设我们有一个文件叫test.xls，位于D:\\Workspace\\Python\\xlrd3-test\\test.xls\r\n其内容如下：\r\n这是一张9行4列的PC主机报价单，当然，价格全是扯淡。\r\n下面使用xlrd程序将PC这张表的内容打印出来。\r\n\r\n01\timport xlrd3\r\n02\t \r\n03\tdef main():\r\n04\t    xlsfile=xlrd3.open_workbook(\"D:\\\\Workspace\\\\Python\\\\xlrd3-test\\\\test.xls\")\r\n05\t    try:\r\n06\t        mysheet = xlsfile.sheet_by_name(\"PC\")\r\n07\t    except:\r\n08\t        print(\"no sheet in %s named PC\")\r\n09\t        return\r\n10\t \r\n11\t    # total rows and cols\r\n12\t    print(\"%d rows, %d cols\"%(mysheet.nrows, mysheet.ncols))\r\n13\t \r\n14\t    for row in range(0, mysheet.nrows):\r\n15\t        temp=\"\"\r\n16\t        for col in range(0, mysheet.ncols):\r\n17\t            if mysheet.cell(row, col).value != None:\r\n18\t                temp+=str(mysheet.cell(row, col).value)+\"\\t\"\r\n19\t        print(temp)\r\n20\t \r\n21\tif __name__ == '__main__':\r\n22\t    main()\r\n输出：\r\n\r\n大功告成！\r\n以上仅是一个入门介绍，关于xlrd更多的信息请参考：\r\n\r\nhttp://packages.python.org/xlrd3/\r\nhttp://www.lexicon.net/sjmachin/xlrd.htm\r\n\r\n###python操作excel表格(xlrd/xlwt)\r\n\r\nhttp://www.cnblogs.com/zhoujie/p/python18.html\r\n\r\n###Python Excel Tutorial （一）：xlrd的安装和读取Excel文件\r\nhttp://huaxia524151.iteye.com/blog/1173828\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}